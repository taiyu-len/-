let s:plugins = {}
" let s:plugins["name"] = "author"
" as in github.com/author/name

" [Editing] {{{
" config for input, operators, etc. doesnt include Mappings
filetype plugin indent on
syntax enable

" Input {{{
let mapleader = " "
let localmapleader = ","

set mouse=a " Enable mouse in all modes
" {{{ Fix Arrow keys for different terminals.
if &term == 'screen-256color'
	map  [1;2A <S-Up>
	map  [1;2B <S-Down>
	map! [1;2A <S-Up>
	map! [1;2B <S-Down>
	set  t_%i=[1;2C " S-Right
	set  t_#4=[1;2D " S-Left
	map  [1;5A <C-Up>
	map  [1;5B <C-Down>
	map  [1;5C <C-Right>
	map  [1;5D <C-Left>
	map! [1;5A <C-Up>
	map! [1;5B <C-Down>
	map! [1;5C <C-Right>
	map! [1;5D <C-Left>
	map   <C-Backspace>
	map!  <C-Backspace>
	map  [3;5~ <C-delete>
	map! [3;5~ <C-delete>
elseif &term == 'dvtm-256color'
	map  [a <S-Up>
	map  [b <S-Down>
	map! [a <S-Up>
	map! [b <S-Down>
	set  t_%i="[1;2C" " S-Right
	set  t_#4="[1;2D" " S-Left
	map  Oa <C-Up>
	map  Ob <C-Down>
	map  Oc <C-Right>
	map  Od <C-Left>
	map! Oa <C-Up>
	map! Ob <C-Down>
	map! Oc <C-Right>
	map! Od <C-Left>
elseif &term == 'rxvt-unicode-256color'
	map [a <S-Up>
	map [b <S-Down>
	map! [a <S-Up>
	map! [b <S-Down>
	set  t_%i=[c " S-Right
	set  t_#4=[d " S-Left
	map  Oa <C-Up>
	map  Ob <C-Down>
	map  Oc <C-Right>
	map  Od <C-Left>
	map! Oa <C-Up>
	map! Ob <C-Down>
	map! Oc <C-Right>
	map! Od <C-Left>
	map   <C-Backspace>
	map!  <C-Backspace>
	map  [3^ <C-delete>
	map! [3^ <C-delete>
endif
" }}}
" }}}
set shiftwidth=0 " make <Tab> inserts tab.
" Auto pairs
let s:plugins["delimitMate"] = "Raimondi"
let delimitMate_expand_cr = 1
" Minor mapping fixes {{{
" remap backspace/delete keys
map  <BS>       X
nmap <C-BS>     db
imap <C-BS>     <C-O>db
nmap <C-Delete> dw
imap <C-Delete> <C-O>dw
" input mode Shift-Arrow changes to visual mode
inoremap <S-Up>    <C-O>v<Up>
inoremap <S-Down>  <C-O>v<Down>
inoremap <S-Right> <C-O>v<Right>
inoremap <S-Left>  <C-O>v<Left>
" normal mode goes to visual mode
nnoremap <S-Up>    v<Up>
nnoremap <S-Down>  v<Down>
nnoremap <S-Right> v<Right>
nnoremap <S-Left>  v<Left>
" shift-arrow moves just like arrow in visual mode
vmap <S-Up>    <Up>
vmap <S-Down>  <Down>
vmap <S-Right> <Right>
vmap <S-Left>  <Left>
" Give Y better behavior
map Y y$
" }}}
" Formatting {{{
set autoindent
set cinoptions+=Ls " placement of labels will be shifted one over.
set cinoptions+=:0 " indent of case: inside switch
set cinoptions+=l1 " case{\n.body.} no alignment inside body. just indent
set cinoptions+=g0 " public:private:protected: will be shifted one over
set cinoptions+=N-s " namespace body has no indent
set cinoptions+=t0 " func return type alignment
set cinoptions+=i0 " base class/constructor init alignment
set cinoptions+=cs " Comment alignment
set cinoptions+=(0,u0,U1 " for Proper alignment
set cinoptions+=Ws "
set cinoptions+=ks
set cinoptions+=m1 " parenthesis acts like brace
set formatoptions+=nj
" }}}
" Operators {{{
set tildeop
" }}}
" Spelling {{{
nnoremap <silent><leader>ss :set spell<cr>1z=:set nospell<cr>
"}}}
" }}}
" [Motion] {{{
" config for navigating the document, using motion keys, etc
" Cursor {{{
" configure movement of cursor
set whichwrap=<,>,[,]          " enable wrapping with cursor keys in all modes
set backspace=indent,eol,start " enable backspace
set virtualedit=onemore,block  " allow cursor one past the line, and anywhere in block mode
" }}}
" Search {{{
set ignorecase  " ignore case by default
set smartcase   " unless there are upper case characters searched
set incsearch
set wrapscan
set magic
" Only show highlight
augroup VIMRC_incsearch_highlight
	autocmd!
	autocmd CmdlineEnter /,\? :set hlsearch
	autocmd CmdlineLeave /,\? :set nohlsearch
augroup END
" }}}
" Marks {{{
" Swap mark jump keys around
nnoremap ' `
nnoremap ` '
" }}}
" Scrolling {{{
set scrolloff=5
set sidescroll=1     " Enable side scrolling
set sidescrolloff=5
set nowrap           " Disable wrapping
" }}}
" Motions {{{
" add surround motions
let s:plugins["vim-surround"] = "tpope"
let s:plugins["vim-repeat"] = "tpope"
let s:plugins["vim-sexp"] = "guns"
let s:plugins["vim-sexp-mappings-for-regular-people"] = "tpope"
let g:sexp_filetypes = 'clojure,scheme,lisp,timl,c,cpp'
let g:sexp_enable_insert_mode_mappings=0
" }}}
" }}}
" [Display] {{{
" Text {{{
set showmatch " show matching pair under cursor
set list
if has("multi_byte") " {{{
set listchars=
	set listchars=tab:‚îÇ‚Äß,trail:‚Ä¢,conceal:Œ¥,precedes:‚Üê,extends:‚Üí
else
	set listchars=tab:\|\ ,trail:.,conceal:%,precedes:^,extends:$
endif " }}}
" }}}
" Margin {{{
set number         " Show current line number
set relativenumber " and relative number for rest of lines
" }}}
" Folding {{{
" Custom fold function {{{
function! VIMRC_fold_function() abort
	let l:tabc = substitute(&listchars, '^.*tab:\(..\).*$','\1','')
	let l:tabc = strchars(l:tabc) == 2 ? l:tabc : '  '
	let l:tabs = strcharpart(l:tabc, 0, 1)
	let l:tabe = strcharpart(l:tabc, 1, 1)
	let l:tab = l:tabs . repeat(l:tabe, &tabstop-1)
	let l:end = 'FOO'
	if (&foldmethod ==? "marker")
		let l:end = substitute(&foldmarker, '.*,', '', '')
	elseif (&foldmethod ==? "syntax")
		let l:end = substitute(getline(v:foldend), '^\s*\([])}]\|\w\+\).*$', '\1', '')
	endif
	return printf("%s...%s [%d ÓÇ°] ", substitute(getline(v:foldstart), '\t', l:tab, 'g'), l:end,
		\ v:foldend - v:foldstart)
endfunction
" }}}
set foldtext=VIMRC_fold_function()
set foldmethod=syntax
set foldclose=
set foldopen+=insert
set foldlevelstart=0
set foldmarker={,}
" }}}
" Conceal {{{
set conceallevel=2
set concealcursor=
"}}}
" Window {{{
set winminheight=0
set winminwidth=0
if has("multi_byte") " {{{
	set fillchars=stl:‚îÅ,stlnc:‚îÄ,vert:‚îÉ,fold:‚ïã,diff:‚ïã
else
	set fillchars=stl:-,stlnc:-,vert:\|,fold:/,diff:/
endif " }}}
" }}}
" Status {{{
set errorbells
set ruler
set laststatus=2
set noshowmode
" Lightline {{{
let s:plugins["lightline.vim"] = "itchyny"
let s:plugins["vim-fugitive"] = "tpope"

function! VIMRC_LLColumn() abort
	let l:max_width = max([len(line('$')), &numberwidth-1])
	let l:col_width = len(col('.'))
	return repeat('¬†', l:max_width - l:col_width - 1) . col('.')
endfunction

function! VIMRC_LLReadonly() abort
	return &readonly && &filetype !=# 'help' ? 'ÓÇ¢' : ''
endfunction

function! VIMRC_LLFugitive() abort
	if exists('*fugitive#head')
		let l:branch = fugitive#head()
		return l:branch !=# '' ? 'ÓÇ† '.l:branch : ''
	endif
	return ''
endfunction

let g:lightline = {}
let g:lightline.colorscheme = 'solarized'
let g:lightline.active = {
	\ 'left' : [['column', 'mode', 'paste'], ['filename', 'modified', 'readonly']],
	\ 'right': [['filetype'], ['gitbranch']] }
let g:lightline.inactive = {
	\ 'right': [['filetype'], ['gitbranch']] }
let g:lightline.component_function = {}
let g:lightline.component_function.column    = 'VIMRC_LLColumn'
let g:lightline.component_function.readonly  = 'VIMRC_LLReadonly'
let g:lightline.component_function.gitbranch = 'VIMRC_LLFugitive'
let g:lightline.component_function_visible_condition = { 'gitbranch': 'call VIMRC_LLFugitive()'}
let g:lightline.separator = { 'left': 'ÓÇ∞', 'right': 'ÓÇ≤' }
let g:lightline.subseparator = { 'left': 'ÓÇ±', 'right': 'ÓÇ≥' }
let g:lightline.mode_map = {
	\ 'n'     : 'N', 'i' : 'I', 'R'     : 'R',
	\ 'v'     : 'V', 'V' : 'V', '\<C-v>': 'V',
	\ 'c'     : 'C', 's' : 's', 'S'     : 'S',
	\ '\<C-s>': 'S', 't' : 'T',
	\ }
" }}}
" }}}
" Theme {{{
function! VIMRC_set_highlight() abort
	highlight Folded     cterm=none ctermfg=145  ctermbg=none
	highlight SpecialKey cterm=bold              ctermbg=None
	" Because all diff colorschemes are fucking garbage
	highlight DiffAdd    NONE cterm=underline ctermbg=22
	highlight DiffChange NONE cterm=underline
	highlight DiffText   NONE cterm=underline ctermbg=17
	highlight DiffDelete NONE                 ctermbg=52 ctermfg=52
endfunction
augroup VIMRC_highlight
	autocmd!
	autocmd ColorScheme * call VIMRC_set_highlight()
augroup END

set background="dark"
colorscheme slate
" }}}
" }}}
" [ManPages] {{{
let s:plugins["vim-man"] = "vim-utils"
set keywordprg=:Man
augroup VIMRC_manpages
	autocmd!
	autocmd FileType man  setlocal nolist
	autocmd FileType help setlocal keywordprg=:help
augroup END
" }}}
" [Command] {{{
" Wild menu {{{
set wildmenu
set wildchar=<TAB>
set wildignorecase
set wildmode=list:longest
" }}}
" "}}}
" [Vim] {{{
" Files And Paths {{{
" Where vim puts things
set exrc   " run .exrc files
set secure " safely
set backup
set backupdir=.
set backupskip=/tmp/*
set undofile
set undodir=~/.vim/undo
set swapfile
set directory=~/.vim/swap//
set path=.,/usr/include,,include;,
set viewdir=~/.vim/view
set viminfofile=~/.vim/viminfo
" }}}
" }}}
" [Packages] {{{
function! VIMRC_run_minpac() " {{{
	packadd minpac
	call minpac#init({'jobs': '1'})
	call minpac#add('k-takata/minpac', {'type': 'opt'})
	for addon in items(s:plugins)
		call minpac#add(addon[1] . '/' . addon[0], {'type': 'opt'})
	endfor
endfunction " }}}

" Reload vimrc, updating the function, call the function
command! PackUpdate source $MYVIMRC | call VIMRC_run_minpac() | call minpac#update()
command! PackClean  source $MYVIMRC | call VIMRC_run_minpac() | call minpac#clean()

" Load pacakges
for addon in keys(s:plugins)
	execute "packadd! " . fnameescape(addon)
endfor
" }}}
" vim: foldmarker={{{,}}}: foldlevel=0: foldmethod=marker
